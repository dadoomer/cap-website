<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link href='http://fonts.googleapis.com/css?family=Lato:300,700' rel='stylesheet' type='text/css'></link>
    <link href='main.css' rel='stylesheet' type='text/css'></link>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <title>CAP</title>
  </head>
  <body>
    <div id="nav_bar">
      <ul>
        <li><a href="/cap/">home</a></li>
        <li><a href="#projects">projects</a></li>
        <li><a href="#publications">publications</a></li>
        <li><a href="#alumni">alumni</a></li>
		<li><a href="#urop">urop</a></li>
      </ul>
    </div>

    <h1>COMPUTER-AIDED PROGRAMMING</h1>

    <div class="mission">
      <p>
        We develop techniques and tools that exploit automated reasoning and large amounts of computing power to tackle challenging programming problems
      </p>
    </div>

    <div class="photo_section">
      <div class="photo_row">
        <div class="photo_container">
          <a href="http://people.csail.mit.edu/asolar/">
            <img
              title="Armando Solar-Lezama, Faculty"
              src="images/asolar-thumb.jpg"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="http://omarcostilla.mit.edu">
            <img
              title="Omar Reyes, Research Scientist"
              src="images/omar-thumb.jpg"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="http://www.jameskoppel.com/">
            <img
              src="images/jimmy-thumb.jpg"
              title="Jimmy Koppel, Postdoctoral Student"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="http://jinala.github.io/">
            <img
              src="images/jeevana-thumb.jpg"
              title="Jeevana Inala, Postdoctoral Student"
              />
          </a>
        </div>
        <div class="photo_container">
	      <a href="https://www.linkedin.com/in/ivankuraj">
	        <img
              src="images/ivan-thumb.jpg"
	          title="Ivan Kuraj, Doctoral Student"
              />
          </a>
        </div><div class="photo_container">
          <a href="http://people.csail.mit.edu/feser/">
	        <img
              src="images/jack-thumb.jpg"
              title="Jack Feser, Doctoral Student"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="">
            <img
              src="images/kliment-thumb.jpg"
              title="Kliment Serafimov, Doctoral Student"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="http://kavigupta.org">
            <img
              src="images/kavi-thumb.jpg"
              title="Kavi Gupta, Doctoral Student"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="https://mlb2251.github.io/">
            <img
              src="images/matt-thumb.jpg"
              title="Matt Bowers, Doctoral Student"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="https://iamleo.space">
            <img
              src="images/default-thumb.png"
              title="Leonardo Cano, Doctoral Student"
              />
          </a>
        </div>
        <div class="photo_container">
          <a href="https://riadas.github.io/">
            <img
              src="images/ria-thumb.png"
              title="Ria Das, Masters Student"
              />
          </a>
        </div>
      </div>
    </div>

    <div class="content">

      <div class="anchor" id="projects"></div>
      <h2>PROJECTS</h2>

      <p>
        <strong>Sketch</strong> &mdash;
        A synthesis-enabled language that allows programmers to write programs with holes and then rely on constraint-based synthesis to discover the missing code.<br/>
        <em>People: <a href="http://people.csail.mit.edu/asolar/">Armando Solar-Lezama</a></em>
      </p>

      <p>
        <a href="http://projects.csail.mit.edu/jeeves/"><strong>Jeeves</strong></a> &mdash;
        A programming language for automatically enforcing security and privacy policies.<br/>
        <em>People: <a href="http://people.csail.mit.edu/jeanyang/">Jean Yang</a></em>
      </p>

      <p>
        <strong>Bellmania</strong> &mdash;
        Deductive synthesis for large-scale implementations of dynamic programming algorithms. Strives to produce cache-oblivious distributed programs using a divide-and-conquer method. Incorporates modern proof techniques with a software refinement paradigm.<br/>
        <em>People: <a href="http://www.cs.tau.ac.il/~shachar/">Shachar Itzhaky</a></em>
      </p>

      <p>
        <strong>Object Spreadsheets</strong> (joint work with <a href="http://sdg.csail.mit.edu/">SDG</a>) &mdash;
        Attempts to make data-driven programming more accessible to end-users by imitating the look-and-feel of spreadsheets. The design comprises of a hybrid tabular-hierarchical data model, a query language for writing formulas, and an IDE.<br/>
        <em>People: <a href="http://www.cs.tau.ac.il/~shachar/">Shachar Itzhaky</a>, <a href="https://mattmccutchen.net/">Matt McCutchen</a></em>
      </p>

      <p>
        <strong>Cyber-Physical Security</strong> &mdash;
        Safety-critical embedded systems are vulnerable to combinations of cyber and physical attacks. Examples include Stuxnet attacks on power grids and GPS spoofing. We use program analysis and synthesis techniques to analyze security vulnerability and develop defense mechanisms.
        <em>People: <a href="http://scungao.github.io/">Sicun Gao</a></em>
      </p>

      <p>
        <strong>Control Design Automation</strong> &mdash;
        To design controllers for dynamical systems is to solve a special class of program synthesis problems. We exploit the connection between control theory and formal methods to develop automated methods for hybrid and nonlinear control.<br/>
        <em>People: <a href="http://scungao.github.io/">Sicun Gao</a></em>
      </p>

      <p>
        <a href="https://bitbucket.org/nadiapolikarpova/synquid"><strong>Synquid</strong></a> &mdash;
        Synquid stands for SYNthesis from liQUID types. It extends the Liquid Types framework, used successfully in program verification, to the domain of program synthesis, exploiting the combination of types and SMT-decidable predicates to generate provably correct programs in a modular fashion.<br/>
        <em>People: <a href="http://people.csail.mit.edu/polikarn/">Nadia Polikarpova</a></em>
      </p>

      <p>
        <strong>Sigma</strong> &mdash;
        Sigma is a probabilistic programming language.  It allows you to specify arbitrarily complex probabilistic models as functional programs, and provides inference procedures to answer questions about the model.  Sigmaâ€™s inference algorithms combine modern statistical inference methods with abstract interpretation, SAT solving, and non-linear constraint solving.<br/>
        <em>People: <a href="https://github.com/zenna">Zenna Tavares</a></em>
      </p>

      <p>
        <strong>MSL</strong> &mdash;
        MSL is a synthesis enabled language for writing bulk-synchronous SPMD implementations.<br/>
        <em>People: Zhilei Xu</em>
      </p>


      <p>
        <strong>Cubix</strong> &mdash;
        Cubix is a framework for language-parametric source-to-source transformation. The ability to automatically rewrite code is critical for everything from automated refactoring to automated bug-fixing. Previous tools would need to be rewritten from scratch for each language because they lacked a way to handle the subtle variations between languages. We're making it possible to build tools that work on every language, and are just as good as tools written specifically for each language. <br/>
        <em>People: <a href="http://www.jameskoppel.com/">Jimmy Koppel</a></em>
      </p>
	  
      <p>
        <strong>Mandate</strong> &mdash;
	    If you write down the formal semantics of a programming language, it should be theoretically possible to automatically generate any tool you want for it. Mandate is a framework for doing this by performing rewrites and abstractions of rules. So far, we have focused on automatically synthesizing control-flow graph generators from operational semantics. <br/>
        <em>People: <a href="http://www.jameskoppel.com/">Jimmy Koppel</a></em>
      </p>

      <p>
        <strong>3cobblers</strong> &mdash;
        3cobblers is an approximate program synthesis framework. Rather than synthesizing a correct program all at once, which can be difficult, it synthesizes a sequence of simpler approximate programs that approaches the correct program.<br/>
        <em>People: <a href="https://www.linkedin.com/in/evanthebouncy">Evan Pu</a></em>
      </p>

      <p>
        <strong>AutoSMT</strong> &mdash;
        AutoSMT is a framework for automatically generating domain-specific rewriters for SMT problems. The generated problem rewriters are auto-tuned to performance of a specific solver for problems from a particular domain.<br/>
        <em>People: <a href="http://rohitsingh.net/">Rohit Singh</a></em>
      </p>


      <div class="anchor" id="publications"></div>
      <h2>PUBLICATIONS</h2>

      <script src="https://bibbase.org/dblp/Solar=Lezama:Armando?jsonp=1&filter=type:inproceedings|article"></script>

      <div class="anchor" id="alumni"></div>
      <h2>ALUMNI</h2>
	  <p>
        <a href="http://www.zenna.org/">Zenna Tavares</a>, Columbia University
      </p>
	  <p>
        <a href="https://evanthebouncy.github.io">Evan Pu</a>, Autodesk Research
      </p>
	  <p>
        <a href="https://www.cs.cornell.edu/~ellisk/">Kevin Ellis</a>, Cornell
      </p>
	  <p>
        <a href="https://xinpl.github.io/">Xin Zhang</a>, Peking University
      </p>
	  <p>
        <a href="https://obastani.github.io/">Osbert Bastani</a>, UPenn
      </p>
	  <p>
        <a href="http://people.csail.mit.edu/polikarn/">Nadia Polikarpova</a>, UCSD
      </p>
      <p>
        <a href="http://scungao.github.io/">Sicun Gao</a>, UCSD
      </p>
	  <p>
        <a href="http://www.cs.tau.ac.il/~shachar/">Shachar Itzhaky</a>, Technion
      </p>
	  <p>
        <a href="http://rohitsingh.net/">Rohit Singh</a>, Citadel
      </p>
      <p>
        <a href="http://people.csail.mit.edu/xkqiu/">Xiaokang Qiu</a>, Purdue University
      </p>
      <p>
        Zhilei Xu, Google
      </p>
      <p>
        <a href="http://kuat.me">Kuat Yessenov</a>, Google
      </p>
      <p>
        <a href="http://www.cs.cmu.edu/~jyang2/">Jean Yang</a>, Carnegie-Mellon University
      </p>
      <p>
        <a href="http://people.csail.mit.edu/rishabh/website/">Rishabh Singh</a>, Google Brain
      </p>
      <p>
        <a href="http://homes.cs.washington.edu/~akcheung/">Alvin Cheung</a>, University of Washington
      </p>

      <div class="anchor" id="urop"></div>
      <h2>UROP</h2>
	  <p>If you are an MIT student and you are interested in working with us, check out our list of open UROP/MEng projects below.</p>

      <p>
        <strong>Parametric Inversion of Non-Invertible Functions </strong> &mdash;
        We are developing exciting algorithms to run complicated programs backwards, literally.
        The goal is straightforward: to take a program (e.g. a rendering function which maps geometry to images), and construct an inverse program (e.g. which maps images to geometry).
        Executing a program backwards is non-trivial, so we apply a combination of semantic program analysis and machine learning to help.
        We have a number of possible projects for a UROP:
        <ul>
          <li>To invert bigger and more complex programs</li>
          As we've indicated, one application we're particularly interested in is vision as the inverse of 3D rendering.
          <li>To extend the kinds of programs we can invert (e.g. to imperative or recursive programs; dynamical systems)</li>
          <li>To invert random variables for Bayesian inference</li>
          <li>To analyze the static and dynamic behavior of the forward function with machine learning to assist with its inversion</li>
        </ul>
        The greater your skill set and interests overlap with the following set, the stronger we urge you to get in touch:
        {program analysis, (deep) machine learning, probabilistic inference, computer graphics, planning, reinforcement learning, constraint solving}
      </p>
      <p>
        <em>Prerequisites:</em>
        <ul>
          <li>Solid programming ability required, in any of Python, Lua, Julia and C++</li>
          <li>Recommended 6.820 and/or 6.885</li>
        </ul>
      </p>
      <p>
        <em>Contact: <a href="http://www.zenna.org">Zenna Tavares</a></em>
      </p>

      <p>	      
        <strong> Reading Programmer's Minds for Smart Renaming </strong>
      </p>
      <p>
	    Suppose you have a codebase, and you want to rename all the Kitten's to Cat's. Easy &mdash; find and replace, right? But what about if you have a variable named "k" or "kt," or a class called "KName" &mdash; should you rename those? There's no mechanical rule to decide, and, as a result, many codebases still have remnants of names that were last used a decade ago.</p>

	  <p>We want to make a smart renaming tool that can figure out what else to rename when you rename a concept. We have a crazy idea for how to do this. It's a blend of program synthesis and causal inference, with a smattering of algorithmic information theory and some optional probablistic modeling. Would you like to help?</p>
	  
      <p>
        <em>Prerequisites:</em>
        <ul>
          <li>No strong requirements, but things that may help: Experience with large codebases, knowledge of functional programmming, knowledge of compilers/programming languages, knowledge of statistics.</li>
        </ul>
      </p>
      <p>
        <em>Contact: <a href="http://www.jameskoppel.com">James Koppel</a></em>
      </p>
      
      <strong> Synthesizing Programming Tools from Language Semantics </strong> &mdash;

	  Program analysis and synthesis tools are promising to make programming 100x easier. Yet today they're rarely used because they're very specialized yet expensive to build. A significant part of
	  developing them lies in creating basic components to discover the structure of code, such as control-flow graph generators and type-checkers. In principle, however, if we start with a formal description of a programming language's semantics, we
	  could generate all of these automatically.

	  Towards that end, we are building <i>Mandate</i>, the world's first control-flow graph generator generator. Mandate inputs the formal semantics of a programming language, and outputs a control-flow graph generator for that language.

      This project can be a good way to learn Haskell and programming-language semantics. We have a number of possible projects for a UROP:

      <ul>
	    <li> Adding support for new languages </li>
	    <li> Adding new abstractions so we can generate a wider variety of CFG generators </li>
	    <li> Integrating Mandate with existing repositories of language semantics </li>
	    <li> (Advanced) Extending our approach to generate components other than control-flow graph generators.</li>
	    <li> (Advanced) Discovering a way to make Mandate generate CFG-generators using a fasting algorithm, so we can create the fastest CFG-generators in the world. </li>
      </ul>

      <p>
        <em>Prerequisites:</em>
        <ul>
          <li>Good programming ability, and interest in functional programming</li>
          <li>Useful courses: 6.035, 6.820, 6.822, 6.826, 6.905</li>
        </ul>
      </p>
      <p>
        <em>Contact: <a href="http://www.jameskoppel.com">James Koppel</a></em>
      </p>


      <strong> Automatically Learning Semantics from a Compiler  </strong>

      <p>Our Mandate framework is bringing us to a world where, if you write down the semantics of a language, you can generate any tool you want for it.</p>

      <p>Now, imagine you didn't have to write down the semantics?</p>

      <p>If you have an interpreter or compiler for a language, then that theoretically already contains all the information about what programs in this language mean. Our goal for this project is to extract that information out and convert it to a human- and machine-readable form using program synthesis techniques. </p>
      
      <p>This is a more advanced project for someone who wants to get chest-deep into program synthesis and learn some Haskell too.</p>

      <p>
        <em>Prerequisites:</em>
        <ul>
          <li>Knowledge of programming-language theory, or the willingness to learn intensely.</li>
          <li>Useful courses: 6.035, 6.820, 6.822, 6.826, 6.905</li>
        </ul>
      </p>
      <p>
        <em>Contact: <a href="http://www.jameskoppel.com">James Koppel</a></em>
      </p>

	  
      <strong>Multi-Language Transformation </strong> &mdash;
      Program transformations power tools ranging from automated bug-fixing to migrating entire projects. We find ways of making tools using 10x less code that can be used by 10x more people. We've built ways of expressing program transformations at a higher level, so that they can run on multiple programming languages, while being just as good as ones built for each programming language (and can transform code better than humans, according to our study).

      We have a number of possible projects for a UROP:

      <ul>
	    <li>Make new multi-language tools. Advanced pattern-matching and code search? Synthesizing glue code? Everything is better when you get 5 languages for the price of 1.5.</li>
        <li>Discovering a generic way to combine program analysis and transformation</li>
        <li>Creating new tools, and adding support for new languages</li>
        One thing we're especially interested in is creating a tool that runs on both an imperative language like C and a functional one like Lisp.
        <li>Automatically deriving more efficient transformations</li>
        The power of our approach comes from a very fancy representation of programs, one which is both very general and very specialized. We've barely tapped into that power. Things we think we can do: automatically parallelize transformations, abstract over both mutable and immutable representations, and generate hyper-efficient code.
      </ul>

      Our <i>Cubix</i> framework pushes the Haskell language to its limits, so, if you like Haskell, working on this project will take your Haskell skills into the sky. Knowledge of compilers will also be helpful.

      <p>
        <em>Prerequisites:</em>
        <ul>
          <li>Solid programming ability, and some skill in Haskell or other functional languages</li>
          <li>Useful courses: 6.035, 6.820, 6.822, 6.826, 6.905</li>
        </ul>
      </p>
      <p>
        <em>Contact: <a href="http://www.jameskoppel.com">James Koppel</a></em>
      </p>

      <div class="logo">
        <img src="http://people.csail.mit.edu/lgoff/images/csail-logo-2C-notext.png" width=100/>
      </div>
    </div>
  </body>
</html>
