<html>
  <head>
    <title>CAP Group - Jeeves for Security</title>
 <STYLE TYPE="text/css">
<!--
BODY
   {
   color:black;
   background-color:white;
   font-family:sans-serif;
   }
-->
</STYLE> 
  </head>
  <body>
    <table width=800 cellpadding=10>
    <tr>
    <td>
      <h2>Jeeves for Security</h2>
      <p>We describe how to use Jeeves for handling access control and
      information concerns in a program.  Jeeves provides a mechanism for the
      programmer to enforce that information exits the system according to the
      appropriate policies.  Jeeves is best for systems where the programmer is
      trusted but has to manage many security policies and their interaction.</p>

      <p>Jeeves is best for a system where the programmer wants to think of
      sensitive values as taking on multiple values depending on the viewer.
      If there are two viewers <i>High</i> (authorized) and <i>Low</i>
      authorized, we can think of sensitive values as being represented as
      <i>(viewer = High) ? data<sub>High</sub> : data<sub>Low</sub></i>.
      While it is easy to write such policies with respect to <i>inputs</i>, it
      is more difficult to correctly write such policies with respect to
      <i>outputs</i>.  Jeeves allows the programmer to attach policies to
      inputs for automatic enforcement on outputs.</p>

      <p>With Jeeves, the programmer can delegate security
      policies for automatic enforcement by the system:
      <ol>
        <li>Attaching policies to sensitive values by creating delegated
        values using the <code>defer</code> construct.</li>
        <li>Using <code>concretize</code> only for values that will be output
        via an effectful computation.</li>
      </ol>
      <p>After the programmer creates a delegated expression for a sensitive
      value, the runtime will automatically track that the value and all
      expressions derived from the value are associated with the policy.  Since
      effects such as <code>print</code> require a concrete value,
      all data that exits the system through an effectful computation must
      adhere to security policies.</p>
      </p>

      <p>On this page we show how to use delegation for security policies on the
      context of a social network example and we discuss how to reason about
      policy enforcement in Jeeves.</p>
      <ul>
        <li><a href="#social_network">Social Network Example</a></li>
        <li><a href="#reasoning">Reasoning About Security Policies</a></li>
      </ul>

      <hr>
      <h3>Social Network Example</h3>
      <a name="social_network">

        <p>It is often difficult to perform the bookkeeping necessary to
        enforce access policies in social networks, where there may be many
        different kinds of data and user relations with fine-grained
        user-provided policies about which data can be revealed to whom.</p>

      <h4>Core Program</h4>
      <p>Consider a social network where users can upload photographs and tag their friends.  We can store users and photographs as follows:<br>
<br>
<code>
data user { uid : user_id; photos : [photo_id] ; friends   : [user_id] }<br>
<br>
data photo { pid : photo_id; image : jpg; owner : user_id; tagged : [user_id]}<br>
</code>
<br>
The goal is to be able to implement access control and information flow with minimal changes to the following function to get the list of users tagged in a photograph.<br>
<br>
<code>
let get_photo_tags (p : photo) : [user_id] = p.tagged<br>
</code>
</p>

    <h4>Information Flow with Delegation</h4>
    <p>Let us define the following output context:</p>
    <p><code>
    data vctxt = { viewer : user_id }
    </code></p>

  <p>We can write the following function to create <code>photo</code> records where there is a policy attached to each tag:</p>
  <code>
  let add_photo_policy (p : photo) : deferred ?vctxt photo =<br>
  &nbsp;&nbsp;<font color="purple">(* Function for adding a policy to a tag. *)</font><br>
  &nbsp;&nbsp;let add_tag_policy (actual_tag : user_id) =<br>
  &nbsp;&nbsp;&nbsp;&nbsp;defer t'
  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (is_friends actual_tag context.viewer)
    then (t' == actual_tag) else (t' == null) } in<br>
  <br>
  &nbsp;&nbsp;<font color="purple">(* The new photo record. *)</font><br>
    &nbsp;&nbsp;{ photo_id = p.photo_id<br>
    &nbsp;&nbsp;; image = p.image<br>
    &nbsp;&nbsp;; owner = p.owner<br>
    &nbsp;&nbsp;; tagged = map add_tag_policy p.tagged }<br>
  </code>
  <p>We have explicitly written the type implicit context parameter, but this
  annotation is not necesary in the actual program.  When concretized in a
  context with some viewer, this delegated value will reveal the actual tag if
  the viewer is friends with the owner and the <code>null</code> tag
  otherwise.</p>

  <p>We can apply the <code>get_photo_tags : photo -> [user_id]</code> to expressions of type <code>deferredd ?vctxt photo</code> and get back expressions of type <code>delegated ?vctxt [user_id]</code>.  The code below shows how we can use <code>concretize</code> to get a concrete list of tags visible to a user.</p>
<code>
  let show_tagged (v : user_id) (p : photo) : unit =<br>
  &nbsp;&nbsp;<font color="purple">(* Get tags. *)</font><br>
  &nbsp;&nbsp;let tags : [user_id] = get_photo_tags p in<br>
  &nbsp;&nbsp;<font color="purple">(* Create a viewer context. *)</font><br>
  &nbsp;&nbsp;let ctxt : vctxt = { viewer_id = v } in<br>
  &nbsp;&nbsp;&nbsp;&nbsp;print_list (concretize ctxt tags)
</code>
  <p>This code will print a list of tags that only show a user if that user
  is friends with the viewer.</p>

<h4>Distributed Policies</h4>
<p>
Instead of having <code>is_friends</code> as the sole basis for the policies of who can view the tags, suppose that tag permissions can be determined by various factors.  For example, perhaps a user can block certain other users from viewing photos.  The programmer can use delegated expressions and default values to leave permissions open.</p>
<code>
  let add_tag_policy (actual_tag : user_id) : user_id =<br>
  &nbsp;&nbsp;defer t'<br>
  &nbsp;&nbsp;&nbsp;&nbsp;{ not (can_view_tag tag context.viewer) implies (t'
  == null) }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;default actual_tag
</code>
<p>The program can set additional permissions that restrict access to the user tag.</p>

<p><a href="">Top</a></p>
<hr>
<h3>Reasoning about Security Policies</h3>
<a name="reasoning">

  <p>Jeeves provides the guarantee that all values that exit the
  system through effectful computation (printing, writing to file) are revealed
  according to the policies associated with relevant inputs.</p>

  <h4>Policies and Code</h4>
  <p>Once a variable <code>x</code> is associated with some policy, all values derived
  from computing with <code>x</code> will have the policy associated.  As long
  as the value remains a delegated expression, copying will retain the policy.
  Consider the following code:</p>
  <p><code>
    let x = defer x' { x' > 0 }<br>
    let y = x
  </code></p>
  <p>The variable <code>y</code> would be associated with the same delegated
  expression.  Since delegated expressions are also concretized with respect to
  the constraint environment, a concretization of <code>y</code> must satisfy
  the constraint <code>y > 0</code>.  Note that the concretization of
  <code>y</code> would also cause <code>x</code> to be associated with a
  concrete program value.</p>

  <h4>Implicit Flows</h4>
  <p>Implicit flows are information leaks that happen from control flow.
  Jeeves has the nice property that all expressions resulting from
  program decisions made based on delegated expressions become delegated
  expressions as well.  Thus Jeeves not allow implicit flows of sensitive
  information that is represented as delegated expressions.  Consider the
  following code:</p>

  <p><code>
  let x = defer x' { x' > 0 }<br>
  let y = if (x >= 0) then 1 else -1<br>
  let z = concretize y
  </code></p>

  <p>Since <code>x</code> is a delegated expression, <code>y</code> becomes a
  guarded delegated expression <code>(x >= 0) ? 1 : -1</code>.  Any
  concretization of <code>y</code> must take the symbolic condition into
  account.</p>

  <h4>Declassification</h4>
  <p>Data can be declassified using the <code>concretize</code> keyword.  Once
  a value is concretized, it is no longer designated as sensitive and becomes
  decoupled from its policies.  The programmer must be careful to use
  <code>concretize</code> carefully.</p>
  <p><a href="">Top</a></p>
<hr>
  <p><a href="index.html">Back to Programming with Delegation</a><br>
    <i>Last updated February 21, 2011.</i></p>
  </tr>
</table>
  </body>
</html>
