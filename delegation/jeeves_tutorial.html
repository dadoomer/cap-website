<html>
  <head>
    <title>CAP Group - Introduction to Jeeves</title>
 <STYLE TYPE="text/css">
<!--
BODY
   {
   color:black;
   background-color:white;
   font-family:sans-serif;
   }
-->
</STYLE> 
  </head>
  <body>
    <table width=800 cellpadding=10>
    <tr>
    <td>
    <h2>Introduction to Jeeves</h2>

    <p>The Jeeves language provides support for <i>delegated expressions</i>, which are nondeterministic program expressions subject to programmer-provided policies.  Jeeves syntax looks like OCaml with additional constructs for nondeterminism and contexts.</p>

    <p>In this introduction, you will learn about the core Jeeves functional language, how to introduce, constrain, and eliminate nondeterminism, and how to use Jeeves contexts to specify richer policies.</p>
    <ul>
      <li><a href="#using">Using Jeeves</a></li>
      <li><a href="#basics">Core Jeeves</a></li>
      <li><a href="#nondeterminism">Language Nondeterminism</a></li>
      <li><a href="#contexts">Jeeves Contexts</a></li>
      <li><a href="#additional">Additional Features</a></li>
    </ul>

    <hr>
    <h3>Using Jeeves</h3>

    <p>We have a Jeeves interpeter implementation that processes the whole program AST before interpreting.  Jeeves has well-defined static and dynamic semantics; the interpreter performs checks over the program before it begins interpeting the program.</p>

    <p><a href="">Top</a></p>

    <hr>
    <h3>Core Jeeves</h3>
    <a name="basics">

      <p>Core Jeeves is a simply-typed &lambda;-calculus-based functional language with syntax similar to OCaml.  Some features of Jeeves that are different from languages like C++/Java are:
      <ul>
        <li>All variables are immutable.</li>
        <li>Everything is an expression and returns a value.</li>
        <li>There are higher-order functions.</li>
      </ul>
      Like many other functional languages, there is a top-level expressions are dynamically scoped and everything else is lexically scoped.
      </p>

      <h4>Types</h4>
      <p>Jeeves has the <code>int</code>, <code>bool</code>, <code>string</code>, <code>float</code>, and <code>list</code> types built in.  The <code>-></code> denotes a function type; <code>int -> bool</code> is the type of a function that takes an argument of type <code>int</code> and returns a value of type <code>bool</code>.</p>
      
      <p>The user can also define record types as follows.</p>

      <p><code>
        data new_record_type = { field1 : int ; field2 : bool }
      </code></p>

      <p>Types are associated with variables with the symbol <code>:</code>, for instance <code>x : int</code>.  At present there is no type inference; type annotations are expected everywhere.</p>

      <h4>Top level</h4>
      <p>The top level of a Jeeves program consists of a series of <code>let</code> statements.</p>

      <p><code>
        let (x : int) = 0<br>
        let (y : int) = 42<br>
        let (x : int) = 42
      </code>
      </p>

      <p>The top-level environment is dynamically scoped, so each variable will have the latest value to which it was bound.  After these expressions are evaluated, <code>x</code> will have value 42.</p>

      <h4>Expressions</h4>
      <p>Jeeves has integers, supports basic arithmetic operations, and has the <code>if ... then ... else</code> for conditionals.</p>

      <p>The <code>let</code> construct exists not just at the top-level, but as an expression with the <code>let ... in</code> syntax.</p>

      <p><code>
        <font color="purple">(* Top-level let. *)</font><br>
        let (result : int) =<br>
        &nbsp;&nbsp;<font color="purple">(* Expression-level let. *)</font><br>
        &nbsp;&nbsp;let (x : int) = 42 in<br>
        &nbsp;&nbsp;&nbsp;&nbsp;x + 1
      </code></p>

      <p>Functions can be declared as variables that take arguments and have a return type.  The <code>fun</code> construct creates anonymous expressions.</p>
      <p><code>
        <font color="purple">(* Top-level function. *)</font><br>
        fun double_inc (x : int) : int =<br>
        <font color="purple">(* Expression level function. *)</font><br>
        &nbsp;&nbsp;let inc (x' : int) : int = x' + 1 in<br>
        &nbsp;&nbsp;&nbsp;&nbsp;inc (inc x)<br>
      </code></p>
      
      <p>We could have also written this code with an anonymous expression-level function as follows.</p>
      <p><code>
        <font color="purple">(* Top-level function. *)</font><br>
        fun double_inc (x : int) : int =<br>
        <font color="purple">(* Expression level function. *)</font><br>
        &nbsp;&nbsp;let (inc : int -> int) = fun (x' : int) -> x' + 1 in<br>
        &nbsp;&nbsp;&nbsp;&nbsp;inc (inc x)
      </code></p>

      <h4>Effects</h4>
      <p>Effectful computations are represented by values with the type <code>unit</code>.  Currently the language supports <code>print</code>:</p>

    <p><code>
      <font color="purple">(* Effects have type unit. *)</font><br>
      let (_ : unit) = print "hello world"
    </code></p>

    The symbol <code>_</code> can be used as a variable name when the program will not used the value produced in subsequent computation.

      <p><a href="">Top</a></p>

      <hr>

      <h3>Language Nondeterminism</h3>
      <a name="nondeterminism">
    <p>In this section we describe how to introduce and constrain nondeterminism, how to get back concrete program values, and how to provide policies on nondetermistic values that refer to the eventual use context.</p>

    <h4>Introducing and Constraining Nondeterminism</h4>
    <p>We can introduce nondeterminism into the program by creating a delegated value:</p>
    <code>let (x : deferred int) = defer x' { x' > 0 }</code>
    <p>The keyword <code>defer</code> creates a delegated expression; the syntax is <code>defer</code> [<i>variable name</i>] { [<i>constraint</i>] }, where the variable name allows the constraint to refer to the current delegated value.  The delegated value of type <code>int</code> has type
    <code>deferred int</code>.</p>
    
    <p>The runtime system computes symbolically with delegated values to keep track of their role in derived expressions.  The runtime system also stores a constraint environment for computing concrete program values that satisfy the constraints.</p>

    <h4>Adding Constraints After the Fact</h4>
    <p>Constraints can be applied after the fact to a variable in scope using the <code>constrain</code> function.</p>
    <p><code>
      <font color="purple">(* constrain has type bool -> unit *)</font><br>
      let (_ : unit) = constrain ( x == 42 )
    </code></p>
    <p>Adding a constraint is an effectful computation, as it modifies the
    constraint environment, so it has return type <code>unit</code>.  The
    constraint environment stores the constraints that have been attached to
    the delegated expression associted with variable <code>x</code>:
    <code>{ x' > 0, x' == 42 }</code>.</p>

    <h4>Delegated Expressions in the Core Program</h4>
    <p>Delegated values can be used as core program values: any function that
    expects a value of type &tau; can take a delegated expression of type
    <code>deferred</code> &tau;.  The polymorphism between delegated expressions and concrete program values allows functions to be oblivious to whether their arguments are delegated expressions.  This allows the programmer to attach policies to the arguments of any Jeeves computation.</p>
    
    <p>We can use <code>x : deferred int</code> as an argument to functions expecting type <code>int</code>.</p>
    <code>
      <font color="purple">(* f has type int -> int *)</font><br>
      let f (v : int) : int = v + 42<br>
      &nbsp;<br>
      <font color="purple">(* We can call f with an argument of type deferred int *)</font><br>
      let x' : int = f x<br>
    </code>
    <p>To evaluate the application of <code>f</code>, the Jeeves runtime system would produce the symbolic result <code>x + 42</code>.  Concretization of this expression or derived expressions must satisfy all constraints on <code>x</code>.</p>

    <p>The Jeeves interpreter handles symbolic conditionals by executing both branches.  Consider the following code:</p>
    <p><code>
    <font color="purple">(* Function for computing absolute value. *)</font><br>
    let absolute_value (v : int) : int =<br>
    &nbsp;&nbsp;if (v >= 0) else v else -v<br>
    &nbsp;<br>
    <font color="purple">(* Absolute value of delegated expression. *)</font><br>
    let abs_x : int = absolute_value x
    </code></p>
    <p>In evaluating this application of <code>absolute_value</code>, the Jeeves runtime would produce the symbolic expression <code>(x >= 0) ? x : -x</code>.  Concretization of this and derived expression would have to satisfy all constraints on <code>x</code>.</p>

    <p>A constraint <i>c</i> added to the constraint environment during evaluation under a symbolic conditional <i>s</i> is added as <i>s &rArr; c</i>.</p>

    <h4>Getting Back a Concrete Program Value</h4>
    <p>The program can request a concrete program value to be computed from a delegated expression by using the <code>concretize</code> keyword.  Concretization of an expression <i>e</i> to the value <i>v</i> adds the constraint <i>e == v</i> to the environment.</p>
    <p><code>
      <font color="purple">(* concretize has type 'a -> option 'a *)</font><br>
      let result : option int = concretize x
    </p></code>
    <p>This code binds <code>result</code> to a value consistent with the
    constraints on <code>x</code>.  The function <code>concretize</code> has
    type <code>delegated</code> &#964; -> <code>option</code> &#964; and returns a value consistent with
    the constraint environment if one exists.  The result is an option type,
    returning <code>some v</code> if there is a satisfying assignment and
    <code>none</code>
    otherwise.  In this case, we get <code>result = 42</code>.</p>

    <h4>Delegated Expressions and Effects</h4>
    <p>Concretization is required before effectful computations such as printing.  Consider the following function:</p>
    <p><code>
      <font color="purple">(* This code does not run. *)</font><br>
      let print_positive (v : int) : unit =<br>
      &nbsp;&nbsp;if (v > 0) then print v else ()
    </code></p>
    <p>At the point where the program is displaying a value based on whether argument <code>v</code> is positive, a decision has to have been made about the actual value of <code>v</code>.  Thus the program has to insert a concretization:</p>
    <p><code>
    let print_positive (v : int) : unit =<br>
    &nbsp;&nbsp;if (v > 0) then print (concretize v) else ()
    </code></p>

    <p><a href="">Top</a></p>

    <hr>
    <h3>Jeeves Contexts</h3>
    <a name="contexts">
      <p>Jeeves contexts allow for richer policies that refer to not just the current delegated value, but also  Suppose we wanted the constraint on the our delegated value to refer to the context in which the value will be concretized.  Jeeves contexts are implicit parameters: the program declares the type of the context upon creating delegated expression, the runtime keeps track of the context argument ("hole"), and program supplies a context of the appropriate type at concretization.  Jeeves rejects programs where a concretization context of the correct type is not provided.</p>
      
    <p>Consider a context
    setting what "mode" the computation is in:</p>
    <code>
    data mode = POS | NEG<br>
    data ctxt { m : mode }<br>
  </code>
  
  <p>We can rewrite our delegated value from before as follows, using the
  <code>context</code> keyword to refer to the context:</p>
  <code>
    let cx : deferred ?ctxt int =<br>
    &nbsp;&nbsp;defer x' { if (context.m == POS) then (x' > 0) else (x' < 0)
    } <br>
  </code>
  <p>The call to <code>concretize</code> must supply the appropriate context:</p>
  <code>
    let cresult : int = <br>
    &nbsp;&nbsp;let c : ctxt = { m = NEG } in<br>
    &nbsp;&nbsp;&nbsp;&nbsp;concretize c (cx + 42)
  </code>
  <p>The <code>?ctxt</code> type annotations are optional: the system can infer
  and propagate the required context types.</p>

  <hr>
  <h3>Additional Features</h3>
  <a name="additional">

    <p>Jeeves supports some additional features to make it easier to program with nondeterminism and constraints.</p>

  <h4>Default Values</h4>
  <p>Default values provide an assignment for values that is used <i>as long as it does not contradict the constraint environment</i>.  This provides some sanity to reasoning about the nondeterminism and provies a useful programming mechanism.  The syntax is as follows.</p>
  <p><code>
    let y = defer y' { y' > 0 } with default 42
  </code></p>

  <h4><code>null</code> values</h4>
  <p>In Jeeves <code>null</code> refers to a special value that can be of any
  type and represents a null value of that type.</p>

  <h4>Bounded Quantification</h4>
  <p>Jeeves supports bounded quantification over all elements of a value:</p>
  <code>
    let lst : list int = [0, 1, defer x, 3]<br>
    let _ : unit = { forall elt in lst . (elt > 0) }<br>
  </code>
  <p>This construct helps simplify policies by providing a convenient
  mechanism for granting access to some piece of sensitive data to all users
  some list.</p>

  <h4>Type-level Constraints</h4>
  <hr>
    <p><a href="index.html">Back to Programming with Delegation</a><br>
    <i>Last updated February 21, 2011.</i></p>
  </tr>
</table>
  </body>
</html>
